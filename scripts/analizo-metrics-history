#!/usr/bin/ruby
# metrics-history
# Generates the metrics of the whole history of an application.
# Antônio Terceiro (terceiro@dcc.ufba.br)
# Luiz Romário Santana Rios (luizromario@gmail.com)
# 
# Usage: metrics-history repository-url
#        metrics-history -f repository-folder
#
require 'rubygems'
require 'grit'
require 'yaml'
require 'benchmark'
require 'ftools'
require 'fileutils'

FILTER = /\.(c|h|cpp|cxx|cc|hpp|java)$/

class Grit::Commit
  def merge?
    self.parents.size > 1
  end
  def parentless
    self.parents.size == 0
  end
  def wanted?
    files = `git show --pretty=format: --name-only #{id}`.split
    matches = (files.any? { |path| path =~ FILTER })
    !merge? && matches 
  end
  def previous_wanted
    if merge? || parentless
      nil
    else
      previous = self.parents.first
      if previous.wanted?
        previous
      else
        previous.previous_wanted
      end
    end
  end
  def wanted_list
    commit = self.wanted? ? self : self.previous_wanted
    if commit
      result = []
      while commit
        result << commit
        commit = commit.previous_wanted
      end
      result
    else
      []
    end
  end
end

class AnalizoRunner
  def self.metrics(commit)
    system("git checkout #{commit} > /dev/null 2>> git.log")
    if "" == yaml_metrics = `analizo-metrics . 2> /dev/null` then
      false
    else
      YAML.load_stream(yaml_metrics).documents
    end
  end
  def self.metricsCSV(commit)
    metr = metrics(commit)
    if metr then
      csv_string = ""
      csv_string << commit.id; csv_string << ","
      pa = commit.previous_wanted
      if pa then
        csv_string << commit.previous_wanted.id
      end
      csv_string << ","
      csv_string << commit.author.name.inspect; csv_string << ","
      csv_string << commit.author.email; csv_string << ","

      csv_string << metr[0].keys.sort.map{|key| metr[0][key]}.join(','); csv_string << ","
      csv_string << `git show --pretty=format: --name-only #{commit.id}`.split.join(',').inspect; csv_string << ","
      csv_string << commit.authored_date.rfc2822.inspect
    end
  end
end

class Message
  def self.done
    puts "Done."
  end
  def self.donwloading
    puts "Downloading the project..."
  end
  def self.fatal(msg)
    puts "Fatal: #{msg}"
  end
  def self.not_implemented(feature = "feature")
    print "Sorry, #{feature} not implemented yet."
  end
  def self.usage
    puts "Usage:\n   #{$PROGRAM_NAME} repository-url\n   #{$PROGRAM_NAME} -f repository-folder"
  end
end

options = {}

argv = ARGV
argv.each_index do |i|
  supported_version_control_systems = [
  # [long_option, short_option]
    ["--svn", "-s"],
    ["--cvs", "-c"]
  ]
  if (ai = argv[i])[0] != "-" and argv[i-1] != "-f" and !options.has_key?(:folder) and !options.has_key?(:url)
    options[:url] = argv[i]
  elsif ("-f" == ai or "--folder" == ai) and !options.has_key?(:folder)  and !options.has_key?(:url)
    options[:folder] = argv[i+1]
  else
    supported_version_control_systems.each do |vcs|
      if (ai == vcs[0] or ai == vcs[1]) and options.has_key?(:version_control)
	options[:version_control] = ai[2..-1]
      end
    end
  end
end

if (options.has_key?(:folder) and options.has_key?(:url)) or (!options.has_key?(:folder) or !options.has_key?(:url))
  Message.usage
  exit
end
if options.has_key?(:version_control)
  Message.not_implemented("#{options[:version_control]} support")
  exit
end

previous_dir = Dir.pwd
begin
  if options.has_key?(:url)
    Dir.chdir("/tmp")
    Message.downloading
    if "" != git_dir = `git clone #{options[:url]}`
      tree = Grit::Repo.new(git_dir = git_dir.split[5]+"..").commits.first
    else
      exit
    end
    Message.done
  elsif options.has_key?(:folder)
    proj_name = ""
    Dir.chdir(git_dir = previous_dir+options[:folder]) do
      proj_name = Dir.pwd.split("/")[-1]
    end
    FileUtils.cp_r(git_dir, "/tmp")
    tree = Grit::Repo.new(git_dir = "/tmp/#{proj_name}").commits.first
  end
rescue Grit::InvalidGitRepositoryError
  Message.fatal("Not a git repository.")
  exit
end
proj_name = git_dir.split("/")[-3]
Dir.chdir(git_dir) do
  system("echo \"Log opened at: #{Time.now}\" >> git.log")
  system("echo \"Log opened at: #{Time.now}\" >> analizo.log")
  system("echo \"Log opened at: #{Time.now}\" >> doxyparse.log")
  system("git checkout master > /dev/null 2>> git.log")

  File.open(previous_dir+"/#{time_start_str = Time.now.strftime('%Y%m%d%H%M%S')}-#{proj_name}-metrics.csv", 'w') do |file|
    file.puts "commit_id,nearest_chngend_ancestral_id,author,e-mail,average_coupiling,average_lcom4,number_of_functions,number_of_modules,number_of_public_functions,total_loc,changed_files,date\n"
    wl = tree.wanted_list
    if wl.size == 0 then
      puts "No relevant commits to proccess"
    else
      print "Processing " 
      if wl.size == 1 then
        puts "one commit"
      else
        puts "#{wl.size} commits..."
      end
    end
    error_counter = 0
    wl.each do |commit|
      if mcsv = AnalizoRunner.metricsCSV(commit) then
        file.puts mcsv
        print "."
      else
        print "E"
        system("echo \"Error processing commit #{commit}.\"")
        system("echo \"Analizo out:\"")
        system("analizo-metrics . >> analizo.log 2>> analizo.log")
        system("echo \"Doxyparse out:\"")
        system("doxyparse . >> doxyparse.log 2>> doxyparse.log")
        error_counter +=1
      end
    end
    if error_counter == 0 then
      puts "\nDone.\n"
    else
      if error_counter == 1 then
        print "\nOne error"
      else
        print "\n#{error_counter} errors"
      end
      puts " ocurred. Check analizo.log and doxyparse.log for more details.\n"
    end
    system("git checkout master > /dev/null 2>> git.log")
  end
  system("echo \"Log closed at: #{Time.now}\" >> git.log")
  system("echo \"Log closed at: #{Time.now}\" >> analizo.log")
  system("echo \"Log closed at: #{Time.now}\" >> doxyparse.log")
  Dir.mkdir(logs_dir = previous_dir+"/#{time_start_str}-#{proj_name}-logs")
  File.move("git.log", logs_dir)
  File.move("analizo.log", logs_dir)
  File.move("doxyparse.log", logs_dir)
end
FileUtils.rm_r(proj_name, :force => true)
